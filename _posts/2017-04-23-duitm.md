---
layout: post
title: 数与堆题目
categories: CPPNotes
description: 
keywords: Cpp
---
2016高一树形结构综合考试题2
考试说明：
1.	考试统一用文件测试，程序只算第一次成绩，请认真检查。
2.	考试期间不允许交流讨论题目。
3.	考试完毕方可测试
4.	考试时间为：6:30-8:30


最小费用（money）
问题描述：
有一个农夫要把一个木板砍成n块给定长度的小木板，每块长度为Li，每次锯都要收取一定费用，这个费用就是据的这个木版的长度。求最小总费用。
输入数据：
	第1行一个整数n <= 20000。
	接下来n行，每i+1行为一个整数Li<=500。
输出数据:
	一行一个整数，最小总费用。 
样例
输入文件： 21 5 8
3
8
5
8
输出文件：
34
数据范围：
60%：n<=1000
100%：n<=20000

第k小数（shu）
问题描述：
输入n个数，以第1个数为根节点，建立一棵二叉排序树，输出这颗二叉排序树的前序遍历，并找出第k小数。
输入：第一行n，k。（n<=10000,k<=10000）
      第二行n个数。
输出：第一行，前序遍历结果。
      第二行，第k小的数。
输入样例：
5 3
3 1 2 5 6
输出样例：
3 1 2 5 6
3

前序遍历（inorder）
题目描述
给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度<=8）。
输入输出格式
输入格式：
2行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。
输出格式：
1行，表示一棵二叉树的先序。

输入输出样例

输入样例#1：
BADC                           
BDCA                                                                                                            
输出样例#1 ：                    
ABCD
```
#include<iostream>
#include<string>
using namespace std;
char q[10000];
	 string a,b;int len;
	 int lena,lenb;
void find(int la,int ra,int l,int r)
{
	if(r<l) return;
	 cout<<b[r];
	 int bj=0;
	 for(int i=la;i<=ra;i++)
	 {
	 	if(a[i]==b[r])
	     {
	     	bj=i;
		 }
	 }
	find(la,bj-1,l,l+bj-la-1);
	find(bj+1,ra,l+bj-la,r-1);		 	
}

int main(){
	freopen("inorder.in","r",stdin);
		freopen("inorder.out","w",stdout);
	 cin>>a;
	 cin>>b;
	 lena=a.size();
	 lenb=b.size();
	 find(0,lena-1,0,lenb-1);
}
```

附加题：
序列合并（merge）
题目描述
有两个长度都是N的序列A和B，在A和B中各取一个数相加可以得到N^2个和，求这N^2个和中最小的N个。
输入输出格式
输入格式：
第一行一个正整数N；
第二行N个整数Ai,满足Ai<=Ai+1且Ai<=10^9;
第三行N个整数Bi, 满足Bi<=Bi+1且Bi<=10^9.
【数据规模】
对于50%的数据中，满足1<=N<=1000；
对于100%的数据中，满足1<=N<=100000。
输出格式：
输出仅一行，包含N个整数，从小到大输出这N个最小的和，相邻数字之间用空格隔开。
输入输出样例
输入样例#1：
3
2 6 6
1 4 8
输出样例#1：
3 6 7

