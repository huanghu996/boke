---
layout: post
title: 动态规划小结
categories: CPPNotes
description: 动态规划
keywords: dg,dp
---
动态规划是比较难学的，以下是本人总结的经验

# 前言
## 动态规划必须有的
  
-   判断转移的条件
-   状态转移方程（处理状态，转移状态）

## 注意点
-  变量的范围

- 前一个状态是否可用（初始化，改变顺序（石子合并中的i））
#### 为何石子合并中的i会想用倒叙
-  根据状态转移而来
    
   因为石子合并需要把每两个石子的和算出来，所以发现倒叙有此效果。

## 思考方向
1.    它的状态是什么？
--状态存过程中变化的量
--f[]存题目问的答案（不一定根据题目来，主要是自己方不方便）
1.    是哪一类题型？
--最长不下降序列，最长公共子序列，01背包，传纸条，堆石头，乘积最大。
1.    我如何判断状态是否转移？
--根据题目判断，题目给的运算规则是什么就怎么写。
1.    如何处理状态？
--题目会给出运算规则
1.    如何转移状态？
--用等号
## 检查错误的方法
  打表

## 拨开云雾见青天
 题目中的问法各种各样，要想象解题过程，看到最本质的东西
 #### 题目描述 Description

```
【问题描述】
帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的n*m 的矩阵，矩阵中的每个元素aij均
为非负整数。游戏规则如下：
1. 每次取数时须从每行各取走一个元素，共n个。m次后取完矩阵所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分= 被取走的元素值*2i，
其中i 表示第i 次取数（从1 开始编号）；
4. 游戏结束总得分为m次取数得分之和。
帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。

输入描述 Input Description
第1行为两个用空格隔开的整数n和m。
第2~n+1 行为n*m矩阵，其中每行有m个用单个空格隔开的非负整数。

输出描述 Output Description
输出 仅包含1 行，为一个整数，即输入矩阵取数后的最大得分。

样例输入 Sample Input
2 3
1 2 3
3 4 2

样例输出 Sample Output
82
```



```
数据范围及提示 Data Size & Hint
样例解释

第 1 次：第1 行取行首元素，第2 行取行尾元素，本次得分为1*21+2*21=6
第2 次：两行均取行首元素，本次得分为2*22+3*22=20
第3 次：得分为3*23+4*23=56。总得分为6+20+56=82
```


 


```
【限制】
60%的数据满足：1<=n, m<=30, 答案不超过1016
100%的数据满足：1<=n, m<=80, 0<=aij<=1000
```
通过这题的取数过程中，我们可以发现，有另外的一个过程与这个是等效的。

这个过程是，把每一层分开，单独合并，结果就是把每一层的结果加起来。（石子合并）

这种找另一个替代的过程的方法叫拨开云雾见青天。

# 经典题型
### 经典问题1：最长不下降序列
     设有整数序列a1，a2，a3，…，am，
     若存在i1<i2<i3<…<in，且ai1<=ai2<=ai3<=…<=ain，则称a1，a2，a3，…，am中有长
     度为n的不下降序列ai1，ai2，ai3，…，ain。
     求序列中最大不下降子序列长度n。
     输入：整数序列（m<=100）
     输出：最大长度
     样例：
     输入 7 25 14 33 108 10 44 87
     输出：
     4 
以前i个数为阶段，设数组F[i]为前i个数中用到第i个数的最大不下降序列长度。
由题意可知，其动态转移方程：
      F[i]=max{F[j]+1,1} (j<i,aj<=ai)
      边界为F[1]=1
      
```
     f[1]=1;
    for(i=2;i<=m;i++)
     {
        max=0;
        for(j=1;j<i;j++)
        if(a[j]<a[i]&&f[j]>max)max=f[j];
       f[i]=max+1;		
     }
```

i表示状态（第几个），f[]存子序列的个数（是题目问的）。

### 经典问题2：最长公共子序列

```
一个给定序列的子序列是在该序列中删去若干元素后得到的序列。
例如: X = (A, B, C, B, D, A, B)
X的子序列:
所有X的子集(集合中元素按原来在X中的顺序排列)
(A, B, D), (B, C, D, B), 等等.
给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，
称Z是序列X和Y的公共子序列。
```



最长公共子序列:公共子序列中长度最长的子序列。
最长公共子序列问题
    给定两个序列X={x1,x2,…,xm}和Y={y1,y2,…, yn}，找出X和Y的最长公共子序列的长度用L[i][j]记录序列和的最长公共子序列的长度。其中， Xi={x1,x2,…,xi}；Yj={y1,y2,…,yj}。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时L[i][j]=0。其它情况下，由最优子结构性质可建立递归关系如下：

![image](http://hboke.nos-eastchina1.126.net/s7-7-1.bmp)

i，j表示状态（是a的第几个与b的第几个），f[]存子序列的个数（是题目问的）。


### 经典问题3：01背包
```
有N件物品和一个容量为V的背包。（每种物品均只有一件）
第i件物品的重量是w[i]，价值是c[i]。
求解将哪些物品装入背包可使价值总和最大。
输入文件
第一行两个数，分别为v、n。（v<=1000,n<=100）
接下来n行每行两个数，分别代表每件物品的重量w[i]和c[i]。
输出文件
装入背包的总价值
输入样例：
10 3
3 4
4 5
5 6
输出样例：
11
```

我们用F[i][j]表示在前 i 件物品中选择若干件放在空间为 j 的背包里所能获得的最大价值。
w[i]为第i件物品的体积，c[i]为第i件物品的价值。
则动态转移方程为：

```
F[i][j] = max{  F[i-1][j-w[i]] + c[i]  (j>=w[i]),  F[i-1][j]  }
```



```
for(i=1;i<=n;i++)
  for(j=0;j<=v;j++)
{
        f[i][j] = f[i-1][j];  
        if(j>= w[i]&&f[i][j]<f[i-1][j-w[i]]+c[i])  
           f[i][j]=f[i-1][j-w[i]]+c[i];
}
```

 #### 优化
          
```
for i=1..N
            for v=V..0
                  f[v]=max{f[v],f[v-w[i]]+c[i]};
```
此优化运用的顺序关系这一特点


 其中的f[v]=max{f[v],f[v-w[i]]+c[i]}就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-w[i]]+c[i]}，因为现在的f[v-w[i]]就相当于原来的f[i-1][v-w[i]]。
         如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-w[i]]推知，即为完全背包。
此外背包问题还有多重背包、混合背包、分组背包、有依赖的背包问题等

v表示状态（体积，因为他问的是怎样装，是装东西，所以发生变化的是体积，所以存储的状态是体积），f[]存价值（是题目问的）。
#### 复杂的背包（多个限制条件）
```
大佬的升级（fate）
Problem Description
最近大佬hy正在玩一款叫做FATE的游戏，为了得到极品装备，大佬hy在不停的杀怪做任务。久而久之大佬hy开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，大佬hy升掉最后一级还需n的经验值，大佬hy还留有m的忍耐度，每杀一个怪大佬hy会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，大佬hy就不会玩这游戏。大佬hy还说了他最多只杀s只怪。请问他能升掉这最后一级吗？
Input
输入第一行输入n，m，k，s(0 < n,m,k,s < 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 < a,b < 20)；分别表示杀掉一只这种怪大佬hy会得到的经验值和会减掉的忍耐度。(每种怪都有无数个)
Output
输出升完这级还能保留的最大忍耐度，如果无法升完这级输出-1。
Sample Input
9 10 2 10
1 1
2 2

Sample Output
1

```

```
#include<iostream>
using namespace std;
int jy[10001],f[100][100],nx[1000];
int main(){
	freopen("fate.in","r",stdin);
	freopen("fate.out","w",stdout);
	int n,m,k,s,bre=0,jyz=10000000;
	cin>>n>>m>>k>>s;
	for(int i=1;i<=k;i++)
	{
		cin>>jy[i]>>nx[i];
	}
	//cout<<"hh";
	for(int i=0;i<=s;i++)
	{
		//for(int j=0;j<=n;j++)
		//{
			//f[i][0]=1000000;
		//}
	}
	int maxq=0;
	for(int i=1;i<=k;i++)
	{
	   for(int j=nx[i];j<=m;j++)
		{
		      for(int t=1;t<=s;t++)
		     {
			
			f[j][t]=max(f[j][t],f[j-nx[i]][t-1]+jy[i]);
			//cout<<" i="<<i<<" j="<<j<<" t="<<t<<" f="<<f[i][j]<<" ";	
			if(f[j][t]>=n&&maxq<=m-j)
			{
				maxq=m-j;
				//cout<<"hh "<<" i="<<i<<" j="<<j<<" t="<<t;
			}
			 }

			
		}

	}
if(maxq==0)
{
	cout<<"-1";
return 0;
}
cout<<maxq;
}

//f[杀怪个数][忍耐度]=经验
//判断条件，max。经验
//符合条件就输出 结果：耐久度。  
```


### 经典问题4：传纸条

```
小渊和小轩通过传纸条进行交流
一个在矩阵的(1,1),一个在(m,n)。
班里每个同学都可以帮他们传递，但只会帮他们一次。
来回两条路上参与传递纸条的学生的好心程度之和的最大值。
1<=m,n<=50
```

很容易想到一个算法：
求出1个纸条从（1，1）到（M，N）的路线最大值。
删除路径上的点值
再求出1个纸条从（M，N） 到（1，1）的路线最大值。
统计两次和
上述算法很容易找出反例，如下图。

![image](http://hboke.nos-eastchina1.126.net/%E4%BC%A0%E7%BA%B8%E6%9D%A1.png)

第1次找最优值传递后，导致第2次无法传递。
#### 分析
贪心算法错误，因此我们需要同时考虑两个纸条的传递。
由于小渊和小轩的路径可逆，因此，尽管出发点不同，但都可以看成同时从(1，1)出发到达(M，N)点。
设f(i1，j1，i2，j2)表示纸条1到达(i1，j1)位置，纸条2到达(i2，j2)位置的最优值。则有，
![image](http://hboke.nos-eastchina1.126.net/%E4%BC%A0%E7%BA%B8%E6%9D%A11.png)



其中 (i1，j1)<> (i2，j2)
1<=i1， i2<=M， 1<=j1 ， j2<=N
时间复杂度O(N2M2)
#### 分析2
另一种思路：每个纸条都需要走M+N步才能达到目标。
因此，设F(k，i1，i2)表示两个纸条都走了K步，第1个纸条横坐标为i1，第2个纸条横坐标为i2的最优值。
则两个纸条的纵坐标分别为j1=K-i1， j2=K-i2 ，状态转移方程如下：

![image](http://hboke.nos-eastchina1.126.net/%E4%BC%A0%E7%BA%B8%E6%9D%A12.png)


其中 i1<>i2
1<=i1， i2<=M，1<=k<=N+M
时间复杂度O((N+M)*M2)

坐标行动态规划，状态表示坐标（每一个都要经历一遍），f[]存坐标权值的和（是题目问的）。

### 经典问题5：堆石头

```
有N堆石子排成一圈(N≤100),现要将石子有次序地合并成一堆.规定每次只能选相临的两堆合并成一堆,并将新的一堆的石子数,记为该次合并的得分。选择一种合并石子的方案,使得做N-1次合并,得分的总和最小
输入数据:
第一行为石子堆数N;
第二行为每堆石子数,每两个数之间用一空格分隔.
输出数据:
合并得分总和最小值
输入样例
4
4 5 9 4
输出样例
43
```

对于N个石子，需要合并多少次？
怎么合并？

#### 算法分析
假设只有2堆石子，显然只有1种合并方案
如果有3堆石子，则有2种合并方案，((1,2),3)和(1,(2,3))
如果有k堆石子呢？
不管怎么合并，总之最后总会归结为2堆，如果我们把最后两堆分开，左边和右边无论怎么合并，都必须满足最优合并方案，整个问题才能得到最优解。如下图：

![image](http://hboke.nos-eastchina1.126.net/%E7%9F%B3%E5%A4%B4%E5%90%88%E5%B9%B6.png)

f[i][j]表示将从第i堆石子合并到第j堆石子的最小得分。

f[i][j]=min(f[i][k]+f[k+1][j]+sum[i][j])(i<=k<=j)

其中f[i,i]=0，sum[i][j]表示将从第i堆石子到第j堆石子合并的总分值
。
阶段是什么？ 
阶段i：石子的每一次合并过程，先两两合并，再三三合并，...最后N堆合并

#### 如何处理圈问题？
方法：可以将这条链延长2倍，扩展成2n-1堆，其中第1堆与n+1堆完全相同，第i堆与n+i堆完全相同，这样我们只要对这2n堆动态规划后，枚举f(1,n),f(2,n+1),…,f(n,2n-1)取最优值即可即可。
时间复杂度为O(8n3),如下图：

![image](http://hboke.nos-eastchina1.126.net/%E7%9F%B3%E5%A4%B4%E5%90%88%E5%B9%B6%E5%9C%88.png)
#### 核心代码

```
for(L=1;L<=n-1;L++)  以合并的次数划分阶段
  for(i=1;i<=2*n-L;i++) 枚举起始位置
{
   j=i+L;  计算结束位置
      for(k=i;k<j;k++)
       {
          f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum[i][j]);
       }
}
```
i，j表示状态（从a[i]到a[j]的状态），f[][]存和（是题目问的）。
先要把每两的和算出来，在算每3个的和，在算每4个……
最后再算到每一个都算到，便可得出结果
