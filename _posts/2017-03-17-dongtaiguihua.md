---
layout: post
title: 动态规划小结
categories: CPPNotes
description: 动态规划
keywords: dg,dp
---
动态规划是比较难学的，以下是本人总结的经验


## 动态规划必须有的
  
  判断转移的条件
  
  状态转移方程（处理状态，转移状态）

#### 注意点
  变量的范围
  前一个状态是否可用（初始化，改变顺序）
#经典题型
经典问题1：最长不下降序列
     设有整数序列a1，a2，a3，…，am，若存在i1<i2<i3<…<in，且ai1<=ai2<=ai3<=…<=ain，则称a1，a2，a3，…，am中有长度为n的不下降序列ai1，ai2，ai3，…，ain。求序列中最大不下降子序列长度n。
输入：整数序列（m<=100）
输出：最大长度
样例：
输入 7 25 14 33 108 10 44 87
输出：
4 
以前i个数为阶段，设数组F[i]为前i个数中用到第i个数的最大不下降序列长度。
由题意可知，其动态转移方程：
      F[i]=max{F[j]+1,1} (j<i,aj<=ai)
      边界为F[1]=1

f[1]=1;
`for(i=2;i<=m;i++)
{
    max=0;
    for(j=1;j<i;j++)
    if(a[j]<a[i]&&f[j]>max)max=f[j];
       f[i]=max+1;		
}`


经典问题2：最长公共子序列
一个给定序列的子序列是在该序列中删去若干元素后得到的序列。
例如: X = (A, B, C, B, D, A, B)
    X的子序列:
所有X的子集(集合中元素按原来在X中的顺序排列)
	 	(A, B, D), (B, C, D, B), 等等.
给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。
最长公共子序列:公共子序列中长度最长的子序列。
最长公共子序列问题
    给定两个序列X={x1,x2,…,xm}和Y={y1,y2,…, yn}，找出X和Y的最长公共子序列的长度
用L[i][j]记录序列和的最长公共子序列的长度。其中， Xi={x1,x2,…,xi}；Yj={y1,y2,…,yj}。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时L[i][j]=0。其它情况下，由最优子结构性质可建立递归关系如下：


经典问题3：01背包
        有N件物品和一个容量为V的背包。（每种物品均只有一件）第i件物品的重量是w[i]，价值是c[i]。求解将哪些物品装入背包可使价值总和最大。
输入文件
第一行两个数，分别为v、n。（v<=1000,n<=100）
接下来n行每行两个数，分别代表每件物品的重量w[i]和c[i]。
输出文件
装入背包的总价值
输入样例：
10 3
3 4
4 5
5 6
输出样例：
11
我们用F[i][j]表示在前 i 件物品中选择若干件放在空间为 j 的背包里所能获得的最大价值。
w[i]为第i件物品的体积，c[i]为第i件物品的价值。
则动态转移方程为：
F[i][j] = max{  F[i-1][j-w[i]] + c[i]  (j>=w[i]),  F[i-1][j]  }

for(i=1;i<=n;i++)
  for(j=0;j<=v;j++)
{
        f[i][j] = f[i-1][j];  
        if(j>= w[i]&&f[i][j]<f[i-1][j-w[i]]+c[i])  
           f[i][j]=f[i-1][j-w[i]]+c[i];
}
 优化
          for i=1..N
            for v=V..0
                  f[v]=max{f[v],f[v-w[i]]+c[i]};
         其中的f[v]=max{f[v],f[v-w[i]]+c[i]}就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-w[i]]+c[i]}，因为现在的f[v-w[i]]就相当于原来的f[i-1][v-w[i]]。
         如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-w[i]]推知，即为完全背包。
此外背包问题还有多重背包、混合背包、分组背包、有依赖的背包问题等

经典问题4：传纸条
小渊和小轩通过传纸条进行交流
一个在矩阵的(1,1),一个在(m,n)。
班里每个同学都可以帮他们传递，但只会帮他们一次。
来回两条路上参与传递纸条的学生的好心程度之和的最大值。
1<=m,n<=50
很容易想到一个算法：
求出1个纸条从（1，1）到（M，N）的路线最大值。
删除路径上的点值
再求出1个纸条从（M，N） 到（1，1）的路线最大值。
统计两次和
上述算法很容易找出反例，如下图。

第1次找最优值传递后，导致第2次无法传递。
分析
贪心算法错误，因此我们需要同时考虑两个纸条的传递。
由于小渊和小轩的路径可逆，因此，尽管出发点不同，但都可以看成同时从(1，1)出发到达(M，N)点。
设f(i1，j1，i2，j2)表示纸条1到达(i1，j1)位置，纸条2到达(i2，j2)位置的最优值。则有，




其中 (i1，j1)<> (i2，j2)
1<=i1， i2<=M， 1<=j1 ， j2<=N
时间复杂度O(N2M2)
分析2
另一种思路：每个纸条都需要走M+N步才能达到目标。
因此，设F(k，i1，i2)表示两个纸条都走了K步，第1个纸条横坐标为i1，第2个纸条横坐标为i2的最优值。
则两个纸条的纵坐标分别为j1=K-i1， j2=K-i2 ，状态转移方程如下：



其中 i1<>i2
1<=i1， i2<=M，1<=k<=N+M
时间复杂度O((N+M)*M2)

经典问题5：堆石头
有N堆石子排成一圈(N≤100),现要将石子有次序地合并成一堆.规定每次只能选相临的两堆合并成一堆,并将新的一堆的石子数,记为该次合并的得分。选择一种合并石子的方案,使得做N-1次合并,得分的总和最小
输入数据:
第一行为石子堆数N;
第二行为每堆石子数,每两个数之间用一空格分隔.
输出数据:
合并得分总和最小值
输入样例
4
4 5 9 4
输出样例
43
    对于N个石子，需要合并多少次？
    怎么合并？

算法分析
假设只有2堆石子，显然只有1种合并方案
如果有3堆石子，则有2种合并方案，((1,2),3)和(1,(2,3))
如果有k堆石子呢？
不管怎么合并，总之最后总会归结为2堆，如果我们把最后两堆分开，左边和右边无论怎么合并，都必须满足最优合并方案，整个问题才能得到最优解。如下图：
f[i][j]表示将从第i堆石子合并到第j堆石子的最小得分。
f[i][j]=min(f[i][k]+f[k+1][j]+sum[i][j])(i<=k<=j)
其中f[i,i]=0，sum[i][j]表示将从第i堆石子到第j堆石子合并的总分值。
阶段是什么？ 
阶段i：石子的每一次合并过程，先两两合并，再三三合并，...最后N堆合并
如何处理圈问题？
方法：可以将这条链延长2倍，扩展成2n-1堆，其中第1堆与n+1堆完全相同，第i堆与n+i堆完全相同，这样我们只要对这2n堆动态规划后，枚举f(1,n),f(2,n+1),…,f(n,2n-1)取最优值即可即可。
时间复杂度为O(8n3),如下图：
核心代码
for(L=1;L<=n-1;L++)  以合并的次数划分阶段
  for(i=1;i<=2*n-L;i++) 枚举起始位置
{
   j=i+L;  计算结束位置
      for(k=i;k<j;k++)
       {
          f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+sum[i][j]);
       }
}

经典问题6：乘积最大
问题描述
    今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：
    设有一个长度为N的数字串，要求选手使用M个乘号将它分成M+1个部分，找出一种分法，使得这M+1个部分的乘积能够为最大。
同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：
有一个数字串：312， 当N=3，M=1时会有以下两种分法：
    1）	3*12=36
    2）	31*2=62
   这时，符合题目要求的结果是：31*2=62
   现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。
输入格式： 
程序的输入共有两行：
   第一行共有2个自然数N，M（6≤N≤40，1≤M≤6）
   第二行是一个长度为N的数字串。
输出格式：
结果显示在屏幕上，相对于输入，应输出所求得的最大乘积（一个自然数）。
输入样例
4  2
1231
输出样例
62
分析
         从题意来看，’*’号的插入方式非常重要。比如样例，如果插入位置为1*2*31时，结果为23；插入位置为12*3*1时，结果为36；插入位置为1*2*31时结果为62，这种方式的值最大。从这点来看，本题与石子合并非常相似。
        设输入的数字串为S，在S1..Si(2<=i<=n)中插入j个*号时，假设在S1..Sk中插入了j-1个*号，则乘式中第j个*号后边的式子Sk+1..Si为常量；
        设f[i][j]表示在长度为i的数字串中插入j个*号的最大乘积，要得到f[i][j]的最大值时，就要得到max{f[k][j-1]*Sk+1..Si}的值；一一枚举k的位置，即可得到max{f[k][j-1]*Sk+1..Sn}的值。最后输出F[n][m]的值即可。


  
